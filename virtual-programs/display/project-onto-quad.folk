Wish the GPU compiles pipeline "projectedFillTriangle" {
    {vec2 p0 vec2 p1 vec2 p2 vec4 color \
     float fx float fy float s float cx float cy float k1 float k2 vec3 quadIHat vec3 quadJHat vec3 quadT \
     fn planeUvToXy fn projectXyOnPlane} {
        mat3 intrinsics = mat3(
            fx, 0.0, 0.0,
            s,   fy, 0.0,
            cx,  cy, 1.0
        );
        vec2 k = vec2(k1, k2);

        mat3 quadR = mat3(
            quadIHat, quadJHat, cross(quadIHat, quadJHat)
        );

        vec2 vertices[4] = vec2[4](p0, p1, p2, p0);
        vec2 p = vertices[gl_VertexIndex];

        return planeUvToXy(p, intrinsics, k, quadR, quadT);
    } {
        return color;
    }
}

Wish the GPU compiles pipeline "projectedCircle" {
    {vec2 center float radius float thickness vec4 color int filled \
     float fx float fy float s float cx float cy float k1 float k2 vec3 quadIHat vec3 quadJHat vec3 quadT \
     fn planeUvToXy fn projectXyOnPlane} {
        // my code
        float r = radius + thickness;
        vec2 vertices[4] = vec2[4](
            center - r,
            vec2(center.x + r, center.y - r),
            vec2(center.x - r, center.y + r),
            center + r
        );
        vec2 result = vertices[gl_VertexIndex];

        // projection code
        mat3 intrinsics = mat3(
            fx, 0.0, 0.0,
            s,   fy, 0.0,
            cx,  cy, 1.0
        );
        vec2 k = vec2(k1, k2);

        mat3 quadR = mat3(
            quadIHat, quadJHat, cross(quadIHat, quadJHat)
        );

        return planeUvToXy(result, intrinsics, k, quadR, quadT);
    } {fn projectXyOnPlane} {
        // projection code
        mat3 intrinsics = mat3(
            fx, 0.0, 0.0,
            s,   fy, 0.0,
            cx,  cy, 1.0
        );
        vec2 k = vec2(k1, k2);

        mat3 quadR = mat3(
            quadIHat, quadJHat, cross(quadIHat, quadJHat)
        );

        vec2 onPlane = projectXyOnPlane(gl_FragCoord.xy, intrinsics, k, quadR, quadT);

        // my code
        float dist = length(onPlane - center) - radius;
        if (filled == 1) {
            return (dist < thickness) ? color : vec4(0, 0, 0, 0);
        } else {
            return (dist < thickness && dist > 0.0) ? color : vec4(0, 0, 0, 0);
        }
    }
}

proc intrinsicsToList {intrinsics} {
    dict with intrinsics {
        return [list $fx $fy $s $cx $cy $k1 $k2]
    }
}
# Wish to draw a triangle on 5 with p0 {-0.05 -0.05} p1 {0.05 -0.05} p2 {0.0 0.05} color red
When display /display/ has intrinsics /intr/ &\
     tag /tag/ has quad /q/ {
    # TODO: ensure tag is on the right display
    set cameraName [lindex $q 0 1]
    set tagToCamera [lindex $q 0 2 2]
    set cameraR [dict get $tagToCamera R]
    set cameraT [dict get $tagToCamera t]
    
    set cameraToDisplayR [lindex [dict get $::space::changers $cameraName "display $display"] 2]
    set displayT [space change $cameraName "display $display" $cameraT]
    set displayR [matmul $cameraToDisplayR $cameraR]

    set intrinsicsList [intrinsicsToList $intr]
    set RTransposed [transpose $displayR] ;# column format to grab i hat and j hat
    set projectArgs [list {*}$intrinsicsList [lindex $RTransposed 0] [lindex $RTransposed 1] $displayT]

    Claim tag $tag has projected arguments $projectArgs
}

When /someone/ wishes to draw a triangle on /tag/ with /...options/ &\
     tag /tag/ has projected arguments /projectArgs/ {
    dict with options {
        if {![info exists layer]} { set layer 0 }
        Wish the GPU draws pipeline "projectedFillTriangle" with arguments \
            [list $p0 $p1 $p2 [getColor $color] {*}$projectArgs] layer $layer
    }
}

When /someone/ wishes to draw a circle on /tag/ with /...options/ &\
     tag /tag/ has projected arguments /projectArgs/ {
    set center [dict get $options center]
    set radius [dict get $options radius]
    set thickness [dict get $options thickness]
    set color [getColor [dict get $options color]]
    set filled [dict_getdef $options filled false]
    set filled [expr {$filled eq false ? 0 : 1}]
    set layer [dict_getdef $options layer 0]

    Wish the GPU draws pipeline "projectedCircle" with arguments \
        [list $center $radius $thickness $color $filled {*}$projectArgs] layer $layer
}